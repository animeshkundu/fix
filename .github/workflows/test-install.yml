name: Installation Tests

on:
  push:
    branches: [main]
    paths:
      - 'website/install.sh'
      - 'website/install.ps1'
      - '.github/workflows/test-install.yml'
      - 'fix-cli/**'
  pull_request:
    branches: [main]
    paths:
      - 'website/install.sh'
      - 'website/install.ps1'
      - '.github/workflows/test-install.yml'
      - 'fix-cli/**'

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

jobs:
  # Build binaries first for full installation tests
  build-binaries:
    uses: ./.github/workflows/build-binaries.yml

  test-install-script-linux:
    name: Test install.sh (Linux)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Test script syntax
      - name: Check script syntax
        run: bash -n website/install.sh

      # Test helper functions work
      - name: Test OS detection function
        run: |
          # Define the function directly to avoid sed compatibility issues
          detect_os() {
            case "$(uname -s)" in
              Darwin) echo "macos" ;;
              Linux) echo "linux" ;;
              MINGW*|MSYS*|CYGWIN*) echo "windows" ;;
              *) echo "unsupported" ;;
            esac
          }
          result=$(detect_os)
          echo "Detected OS: $result"
          [ "$result" = "linux" ] || exit 1

      - name: Test architecture detection function
        run: |
          # Define the function directly
          detect_arch() {
            case "$(uname -m)" in
              x86_64|amd64) echo "x86_64" ;;
              arm64|aarch64) echo "aarch64" ;;
              *) echo "unsupported" ;;
            esac
          }
          result=$(detect_arch)
          echo "Detected arch: $result"
          [ "$result" = "x86_64" ] || [ "$result" = "aarch64" ] || exit 1

      # Test install directory creation
      - name: Test install directory creation
        run: |
          mkdir -p "$HOME/.local/bin"
          [ -d "$HOME/.local/bin" ] || exit 1
          echo "Install directory created successfully"

      # Test model directory creation
      - name: Test model directory creation
        run: |
          mkdir -p "$HOME/.config/fix"
          [ -d "$HOME/.config/fix" ] || exit 1
          echo "Model directory created successfully"

      # Simulate binary installation (without actual download)
      - name: Simulate binary installation
        run: |
          # Create a mock binary
          echo '#!/bin/bash' > "$HOME/.local/bin/fix"
          echo 'echo "git status"' >> "$HOME/.local/bin/fix"
          chmod +x "$HOME/.local/bin/fix"

          # Verify binary works
          result=$("$HOME/.local/bin/fix" "gti status")
          echo "Mock binary output: $result"
          [ "$result" = "git status" ] || exit 1

  test-install-script-macos:
    name: Test install.sh (macOS)
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4

      - name: Check script syntax
        run: bash -n website/install.sh

      - name: Test OS detection function
        run: |
          # Define the function directly (macOS sed has different behavior)
          detect_os() {
            case "$(uname -s)" in
              Darwin) echo "macos" ;;
              Linux) echo "linux" ;;
              MINGW*|MSYS*|CYGWIN*) echo "windows" ;;
              *) echo "unsupported" ;;
            esac
          }
          result=$(detect_os)
          echo "Detected OS: $result"
          [ "$result" = "macos" ] || exit 1

      - name: Test architecture detection function
        run: |
          # Define the function directly
          detect_arch() {
            case "$(uname -m)" in
              x86_64|amd64) echo "x86_64" ;;
              arm64|aarch64) echo "aarch64" ;;
              *) echo "unsupported" ;;
            esac
          }
          result=$(detect_arch)
          echo "Detected arch: $result"
          [ "$result" = "aarch64" ] || exit 1

      - name: Test install directory creation
        run: |
          mkdir -p "$HOME/.local/bin"
          [ -d "$HOME/.local/bin" ] || exit 1

      # Test macOS model path (Library/Application Support)
      - name: Test macOS config directory
        run: |
          # The CLI uses dirs::config_dir() which on macOS is ~/Library/Application Support
          config_dir="$HOME/Library/Application Support/fix"
          mkdir -p "$config_dir"
          [ -d "$config_dir" ] || exit 1
          echo "macOS config directory created: $config_dir"

  test-install-ps1-windows:
    name: Test install.ps1 (Windows)
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      # Test PowerShell script syntax
      - name: Check script syntax
        shell: pwsh
        run: |
          $errors = $null
          $ast = [System.Management.Automation.Language.Parser]::ParseFile(
            "website/install.ps1",
            [ref]$null,
            [ref]$errors
          )
          if ($errors.Count -gt 0) {
            $errors | ForEach-Object {
              Write-Host "Line $($_.Extent.StartLineNumber):$($_.Extent.StartColumnNumber) - $($_.Message)" -ForegroundColor Red
            }
            exit 1
          }
          Write-Host "PowerShell script syntax is valid"

      # Test architecture detection
      - name: Test architecture detection
        shell: pwsh
        run: |
          $arch = if ([Environment]::Is64BitOperatingSystem) { "x86_64" } else { "i686" }
          Write-Host "Detected architecture: $arch"
          if ($arch -ne "x86_64") {
            Write-Error "Expected x86_64 on GitHub runner"
            exit 1
          }

      # Test install directory creation
      - name: Test install directory creation
        shell: pwsh
        run: |
          $installDir = "$env:LOCALAPPDATA\fix"
          New-Item -ItemType Directory -Path $installDir -Force | Out-Null
          if (-not (Test-Path $installDir)) {
            Write-Error "Failed to create install directory"
            exit 1
          }
          Write-Host "Install directory created: $installDir"

      # Test model directory creation (APPDATA)
      - name: Test model directory creation
        shell: pwsh
        run: |
          $modelDir = "$env:APPDATA\fix"
          New-Item -ItemType Directory -Path $modelDir -Force | Out-Null
          if (-not (Test-Path $modelDir)) {
            Write-Error "Failed to create model directory"
            exit 1
          }
          Write-Host "Model directory created: $modelDir"

      # Test PATH modification logic
      - name: Test PATH modification
        shell: pwsh
        run: |
          $installDir = "$env:LOCALAPPDATA\fix"
          $testPath = "C:\existing\path;C:\another\path"

          # Test that we can detect if path is not in PATH
          if ($testPath -notlike "*$installDir*") {
            Write-Host "Correctly detected install dir not in PATH"
          } else {
            Write-Error "PATH detection logic failed"
            exit 1
          }

          # Test that we can detect if path IS in PATH
          $testPath2 = "$testPath;$installDir"
          if ($testPath2 -like "*$installDir*") {
            Write-Host "Correctly detected install dir in PATH"
          } else {
            Write-Error "PATH detection logic failed"
            exit 1
          }

      # Test profile path detection
      - name: Test profile path detection
        shell: pwsh
        run: |
          $profilePath = $PROFILE.CurrentUserCurrentHost
          Write-Host "PowerShell profile path: $profilePath"
          if (-not $profilePath) {
            Write-Error "Could not determine profile path"
            exit 1
          }

      # Simulate binary installation
      - name: Simulate binary installation
        shell: pwsh
        run: |
          $installDir = "$env:LOCALAPPDATA\fix"
          $exePath = "$installDir\fix.exe"

          # Create a mock executable (batch file renamed to .exe won't work, so just test path)
          "mock" | Out-File -FilePath $exePath

          if (Test-Path $exePath) {
            Write-Host "Mock binary created at: $exePath"
          } else {
            Write-Error "Failed to create mock binary"
            exit 1
          }

  test-install-wsl:
    name: Test install.sh (WSL)
    runs-on: windows-latest
    steps:
      - name: Configure git for LF line endings
        run: |
          git config --global core.autocrlf false
          git config --global core.eol lf

      - uses: actions/checkout@v4

      - name: Setup WSL
        uses: Vampire/setup-wsl@v3
        with:
          distribution: Ubuntu-22.04

      # Test WSL detection in the script
      - name: Test WSL detection
        shell: wsl-bash {0}
        run: |
          # The is_wsl function from install.sh
          is_wsl() {
            grep -qiE "(microsoft|wsl)" /proc/version 2>/dev/null
          }

          if is_wsl; then
            echo "Correctly detected WSL environment"
          else
            echo "ERROR: Should have detected WSL"
            exit 1
          fi

      - name: Check script syntax in WSL
        shell: wsl-bash {0}
        run: bash -n website/install.sh

      - name: Test OS detection in WSL
        shell: wsl-bash {0}
        run: |
          # Source the detect_os function
          detect_os() {
            case "$(uname -s)" in
              Darwin) echo "macos" ;;
              Linux) echo "linux" ;;
              MINGW*|MSYS*|CYGWIN*) echo "windows" ;;
              *) echo "unsupported" ;;
            esac
          }

          result=$(detect_os)
          echo "Detected OS in WSL: $result"
          [ "$result" = "linux" ] || exit 1

      - name: Test install directories in WSL
        shell: wsl-bash {0}
        run: |
          mkdir -p "$HOME/.local/bin"
          mkdir -p "$HOME/.config/fix"

          [ -d "$HOME/.local/bin" ] || exit 1
          [ -d "$HOME/.config/fix" ] || exit 1

          echo "WSL install directories created successfully"
          echo "Binary would go to: $HOME/.local/bin/fix"
          echo "Model would go to: $HOME/.config/fix/"

  test-shell-integration:
    name: Test Shell Integration Functions
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Test bash function syntax
      - name: Test bash function
        run: |
          # Test a simple bash function to verify syntax
          bash -c '
          function fix {
              if [[ -n "$1" ]]; then
                  echo "direct: $@"
              else
                  echo "No args"
              fi
          }
          result=$(fix "test command")
          echo "Result: $result"
          [[ "$result" == "direct: test command" ]] || exit 1
          '
          echo "Bash function syntax is valid"

      # Test zsh function syntax
      - name: Test zsh function
        run: |
          # Install zsh if needed
          sudo apt-get update && sudo apt-get install -y zsh

          # Test zsh function
          zsh -c '
          function fix {
              if [[ -n "$1" ]]; then
                  echo "direct: $@"
              else
                  echo "No args"
              fi
          }
          result=$(fix "test command")
          [[ "$result" == "direct: test command" ]] || exit 1
          '
          echo "Zsh function syntax is valid"

      # Test fish function syntax
      - name: Test fish function
        run: |
          # Install fish
          sudo apt-get install -y fish

          # Test fish function
          fish -c '
          function fix --description "Fix the last command"
              if test (count $argv) -gt 0
                  echo "direct: $argv"
              else
                  echo "No correction needed"
              end
          end
          fix "test command"
          ' | grep -q "direct: test command"
          echo "Fish function syntax is valid"

      # Test tcsh alias syntax
      - name: Test tcsh alias
        run: |
          # Install tcsh
          sudo apt-get install -y tcsh

          # Test tcsh alias (simplified version)
          tcsh -c '
          alias fixtest "echo test"
          fixtest
          ' | grep -q "test"
          echo "Tcsh alias syntax is valid"

  # Test that profile files are actually modified correctly
  test-profile-modification:
    name: Test Profile Modification
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Bash profile test
      - name: Test bash profile modification
        run: |
          # Backup existing bashrc
          cp ~/.bashrc ~/.bashrc.backup 2>/dev/null || true

          # Create a clean bashrc
          echo "# Clean bashrc for testing" > ~/.bashrc

          # Add a simplified fix function for testing
          echo "" >> ~/.bashrc
          echo "# fix - AI-powered shell command corrector" >> ~/.bashrc
          echo 'function fix { command fix "$@"; }' >> ~/.bashrc

          # Verify the profile contains the fix function
          grep -q "fix - AI-powered shell command corrector" ~/.bashrc || (echo "FAIL: Comment not found" && exit 1)
          grep -q "command fix" ~/.bashrc || (echo "FAIL: command fix not found" && exit 1)

          echo "PASS: Bash profile modification verified"

          # Restore
          mv ~/.bashrc.backup ~/.bashrc 2>/dev/null || true

      # Zsh profile test
      - name: Test zsh profile modification
        run: |
          sudo apt-get update && sudo apt-get install -y zsh

          # Create clean zshrc
          echo "# Clean zshrc for testing" > ~/.zshrc

          # Add a simplified zsh function for testing
          echo "" >> ~/.zshrc
          echo "# fix - AI-powered shell command corrector" >> ~/.zshrc
          echo 'function fix { command fix "$@"; }' >> ~/.zshrc

          # Verify
          grep -q "fix - AI-powered shell command corrector" ~/.zshrc || exit 1
          grep -q "command fix" ~/.zshrc || exit 1

          echo "PASS: Zsh profile modification verified"

      # Fish function file test
      - name: Test fish function file creation
        run: |
          sudo apt-get install -y fish

          # Create fish function file
          mkdir -p ~/.config/fish/functions
          echo "# fix - AI-powered shell command corrector" > ~/.config/fish/functions/fix.fish
          echo "function fix --description 'Fix command'" >> ~/.config/fish/functions/fix.fish
          echo "    command fix \$argv" >> ~/.config/fish/functions/fix.fish
          echo "end" >> ~/.config/fish/functions/fix.fish

          # Verify file exists and has correct content
          [ -f ~/.config/fish/functions/fix.fish ] || exit 1
          grep -q "fix - AI-powered shell command corrector" ~/.config/fish/functions/fix.fish || exit 1
          grep -q "command fix" ~/.config/fish/functions/fix.fish || exit 1

          echo "PASS: Fish function file creation verified"

      # Tcsh profile test
      - name: Test tcsh profile modification
        run: |
          sudo apt-get install -y tcsh

          # Create clean tcshrc
          echo "# Clean tcshrc for testing" > ~/.tcshrc

          # Add tcsh alias (simplified for testing)
          echo "" >> ~/.tcshrc
          echo "# fix - AI-powered shell command corrector" >> ~/.tcshrc
          echo "alias fixlast 'fix'" >> ~/.tcshrc

          # Verify
          grep -q "fix - AI-powered shell command corrector" ~/.tcshrc || exit 1
          grep -q "alias fixlast" ~/.tcshrc || exit 1

          echo "PASS: Tcsh profile modification verified"

      # Test idempotency - running configure twice shouldn't duplicate
      - name: Test idempotency (no duplicate entries)
        run: |
          # Create bashrc with function already present
          echo "# Clean bashrc" > ~/.bashrc
          echo "" >> ~/.bashrc
          echo "# fix - AI-powered shell command corrector" >> ~/.bashrc
          echo "fix() { echo test; }" >> ~/.bashrc

          # Count occurrences before
          count_before=$(grep -c "fix - AI-powered shell command corrector" ~/.bashrc)

          # Simulate what install.sh does - check if already configured
          if grep -q "fix - AI-powered shell command corrector" ~/.bashrc 2>/dev/null; then
            echo "Already configured - skipping"
          else
            echo "Would add function"
          fi

          # Count occurrences after
          count_after=$(grep -c "fix - AI-powered shell command corrector" ~/.bashrc)

          if [ "$count_before" = "$count_after" ]; then
            echo "PASS: Idempotency check - no duplicates added"
          else
            echo "FAIL: Duplicate entries were added"
            exit 1
          fi

  # Full end-to-end installation test with actual binaries
  test-full-install-linux:
    name: Full Install Test (Linux, ${{ matrix.shell }})
    runs-on: ubuntu-latest
    needs: build-binaries
    strategy:
      fail-fast: false
      matrix:
        shell: [bash, zsh, fish]
    steps:
      - uses: actions/checkout@v4

      - name: Download pre-built binary
        uses: actions/download-artifact@v4
        with:
          name: fix-binary-x86_64-unknown-linux-gnu
          path: binary

      - name: Install shell
        if: matrix.shell != 'bash'
        run: |
          sudo apt-get update
          sudo apt-get install -y ${{ matrix.shell }}

      - name: Install binary to ~/.local/bin
        run: |
          mkdir -p ~/.local/bin
          cp binary/fix-x86_64-unknown-linux-gnu ~/.local/bin/fix
          chmod +x ~/.local/bin/fix
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Verify binary works
        run: |
          ~/.local/bin/fix --help
          ~/.local/bin/fix --show-config || echo "Config displayed"

      - name: Setup shell profile
        run: |
          export SHELL=$(which ${{ matrix.shell }})
          echo "Setting up shell integration for $SHELL"

          case "${{ matrix.shell }}" in
            bash)
              echo "" >> ~/.bashrc
              echo "# fix - AI-powered shell command corrector" >> ~/.bashrc
              echo 'function fix { command fix "$@"; }' >> ~/.bashrc
              ;;
            zsh)
              echo "" >> ~/.zshrc
              echo "# fix - AI-powered shell command corrector" >> ~/.zshrc
              echo 'function fix { command fix "$@"; }' >> ~/.zshrc
              ;;
            fish)
              mkdir -p ~/.config/fish/functions
              echo "# fix - AI-powered shell command corrector" > ~/.config/fish/functions/fix.fish
              echo "function fix; command fix \$argv; end" >> ~/.config/fish/functions/fix.fish
              ;;
          esac

      - name: Verify shell integration configured
        run: |
          # Verify function was written to config file
          case "${{ matrix.shell }}" in
            bash)
              grep -q "fix - AI-powered shell command corrector" ~/.bashrc || (echo "FAIL: function not in bashrc" && exit 1)
              grep -q "command fix" ~/.bashrc || (echo "FAIL: command fix not in bashrc" && exit 1)
              ;;
            zsh)
              grep -q "fix - AI-powered shell command corrector" ~/.zshrc || (echo "FAIL: function not in zshrc" && exit 1)
              grep -q "command fix" ~/.zshrc || (echo "FAIL: command fix not in zshrc" && exit 1)
              ;;
            fish)
              grep -q "fix - AI-powered shell command corrector" ~/.config/fish/functions/fix.fish || (echo "FAIL: function not in fish config" && exit 1)
              ;;
          esac
          echo "PASS: Shell function written to config"

      - name: Test binary works directly
        run: |
          # Verify binary is callable and working
          ~/.local/bin/fix --help | grep -q "AI-powered" || (echo "FAIL: binary not working" && exit 1)
          echo "PASS: Binary is functional"

  test-full-install-macos:
    name: Full Install Test (macOS)
    runs-on: macos-14
    needs: build-binaries
    steps:
      - uses: actions/checkout@v4

      - name: Download pre-built binary
        uses: actions/download-artifact@v4
        with:
          name: fix-binary-aarch64-apple-darwin
          path: binary

      - name: Install binary
        run: |
          mkdir -p ~/.local/bin
          cp binary/fix-aarch64-apple-darwin ~/.local/bin/fix
          chmod +x ~/.local/bin/fix
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Verify binary works
        run: |
          ~/.local/bin/fix --help
          ~/.local/bin/fix --show-config || echo "Config displayed"

      - name: Setup zsh profile (macOS default)
        run: |
          echo "" >> ~/.zshrc
          echo "# fix - AI-powered shell command corrector" >> ~/.zshrc
          echo 'function fix { command fix "$@"; }' >> ~/.zshrc

      - name: Verify shell integration configured
        run: |
          # Verify function was written to zshrc
          grep -q "fix - AI-powered shell command corrector" ~/.zshrc || (echo "FAIL: function not in zshrc" && exit 1)
          grep -q "command fix" ~/.zshrc || (echo "FAIL: command fix not in zshrc" && exit 1)
          echo "PASS: Shell function written to zshrc"

      - name: Test binary works directly
        run: |
          # Verify binary is callable and working
          ~/.local/bin/fix --help | grep -q "AI-powered" || (echo "FAIL: binary not working" && exit 1)
          echo "PASS: Binary is functional on macOS"

  test-full-install-windows:
    name: Full Install Test (Windows)
    runs-on: windows-latest
    needs: build-binaries
    steps:
      - uses: actions/checkout@v4

      - name: Download pre-built binary
        uses: actions/download-artifact@v4
        with:
          name: fix-binary-x86_64-pc-windows-msvc
          path: binary

      - name: Install binary
        shell: pwsh
        run: |
          $installDir = "$env:LOCALAPPDATA\fix"
          New-Item -ItemType Directory -Path $installDir -Force | Out-Null
          Copy-Item binary/fix-x86_64-pc-windows-msvc.exe "$installDir\fix.exe"
          echo "$installDir" >> $env:GITHUB_PATH

      - name: Verify binary works
        shell: pwsh
        run: |
          & "$env:LOCALAPPDATA\fix\fix.exe" --help
          & "$env:LOCALAPPDATA\fix\fix.exe" --show-config

      - name: Setup PowerShell profile
        shell: pwsh
        run: |
          $profileDir = Split-Path $PROFILE.CurrentUserCurrentHost -Parent
          New-Item -ItemType Directory -Path $profileDir -Force | Out-Null

          # Add a simplified fix function for testing
          Add-Content -Path $PROFILE.CurrentUserCurrentHost -Value ""
          Add-Content -Path $PROFILE.CurrentUserCurrentHost -Value "# fix - AI-powered shell command corrector"
          Add-Content -Path $PROFILE.CurrentUserCurrentHost -Value 'function fix { & "$env:LOCALAPPDATA\fix\fix.exe" @args }'

      - name: Test PowerShell function invokes binary
        shell: pwsh
        run: |
          . $PROFILE.CurrentUserCurrentHost
          $output = fix --help
          if ($output -match "AI-powered") {
            Write-Host "PASS: PowerShell function correctly invokes binary"
          } else {
            Write-Error "FAIL: Function output doesn't contain expected text"
            exit 1
          }

  # Test CMD batch installer
  test-install-cmd-windows:
    name: Test install.cmd (Windows CMD)
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check batch script exists
        shell: cmd
        run: |
          if not exist website\install.cmd (
            echo FAIL: install.cmd not found
            exit /b 1
          )
          echo PASS: install.cmd exists

      - name: Test batch script syntax
        shell: cmd
        run: |
          REM Verify script doesn't have obvious syntax errors by parsing first few lines
          type website\install.cmd | findstr /c:"@echo off" >nul
          if %ERRORLEVEL% neq 0 (
            echo FAIL: Script missing @echo off
            exit /b 1
          )
          echo PASS: Script syntax looks valid

      - name: Test directory creation logic
        shell: cmd
        run: |
          set "INSTALL_DIR=%LOCALAPPDATA%\fix-test"
          if not exist "%INSTALL_DIR%" mkdir "%INSTALL_DIR%"
          if not exist "%INSTALL_DIR%" (
            echo FAIL: Could not create install directory
            exit /b 1
          )
          rmdir /s /q "%INSTALL_DIR%"
          echo PASS: Directory creation works

      - name: Test architecture detection
        shell: cmd
        run: |
          if "%PROCESSOR_ARCHITECTURE%"=="AMD64" (
            set "ARCH=x86_64"
          ) else if "%PROCESSOR_ARCHITECTURE%"=="x86" (
            if defined PROCESSOR_ARCHITEW6432 (
              set "ARCH=x86_64"
            ) else (
              set "ARCH=i686"
            )
          ) else (
            set "ARCH=x86_64"
          )
          echo Detected architecture: %ARCH%
          if "%ARCH%"=="" (
            echo FAIL: Architecture detection failed
            exit /b 1
          )
          echo PASS: Architecture detection works

      - name: Test curl availability
        shell: cmd
        run: |
          where curl >nul 2>&1
          if %ERRORLEVEL% neq 0 (
            echo FAIL: curl not found
            exit /b 1
          )
          echo PASS: curl is available

      - name: Test model directory creation
        shell: cmd
        run: |
          set "MODEL_DIR=%APPDATA%\fix-test"
          if not exist "%MODEL_DIR%" mkdir "%MODEL_DIR%"
          if not exist "%MODEL_DIR%" (
            echo FAIL: Could not create model directory
            exit /b 1
          )
          rmdir /s /q "%MODEL_DIR%"
          echo PASS: Model directory creation works

  # Full CMD installation test with actual binary
  test-full-install-cmd-windows:
    name: Full Install Test (Windows CMD)
    runs-on: windows-latest
    needs: build-binaries
    steps:
      - uses: actions/checkout@v4

      - name: Download pre-built binary
        uses: actions/download-artifact@v4
        with:
          name: fix-binary-x86_64-pc-windows-msvc
          path: binary

      - name: Install binary via CMD
        shell: cmd
        run: |
          set "INSTALL_DIR=%LOCALAPPDATA%\fix"
          if not exist "%INSTALL_DIR%" mkdir "%INSTALL_DIR%"
          copy binary\fix-x86_64-pc-windows-msvc.exe "%INSTALL_DIR%\fix.exe"
          copy binary\wit-x86_64-pc-windows-msvc.exe "%INSTALL_DIR%\wit.exe"
          echo Binaries installed to %INSTALL_DIR%

      - name: Verify binary works via CMD
        shell: cmd
        run: |
          "%LOCALAPPDATA%\fix\fix.exe" --help | findstr /c:"AI-powered" >nul
          if %ERRORLEVEL% neq 0 (
            echo FAIL: fix binary not working correctly
            exit /b 1
          )
          echo PASS: fix binary works via CMD

      - name: Verify wit binary works via CMD
        shell: cmd
        run: |
          "%LOCALAPPDATA%\fix\wit.exe" --help | findstr /c:"Smart shell" >nul
          if %ERRORLEVEL% neq 0 (
            echo FAIL: wit binary not working correctly
            exit /b 1
          )
          echo PASS: wit binary works via CMD
