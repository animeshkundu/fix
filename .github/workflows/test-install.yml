name: Installation Tests

on:
  push:
    branches: [main]
    paths:
      - 'website/install.sh'
      - 'website/install.ps1'
      - '.github/workflows/test-install.yml'
      - 'fix-cli/**'
  pull_request:
    branches: [main]
    paths:
      - 'website/install.sh'
      - 'website/install.ps1'
      - '.github/workflows/test-install.yml'
      - 'fix-cli/**'

jobs:
  # Build binaries first for full installation tests
  build-binaries:
    uses: ./.github/workflows/build-binaries.yml

  test-install-script-linux:
    name: Test install.sh (Linux)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Test script syntax
      - name: Check script syntax
        run: bash -n website/install.sh

      # Test helper functions work
      - name: Test OS detection function
        run: |
          # Define the function directly to avoid sed compatibility issues
          detect_os() {
            case "$(uname -s)" in
              Darwin) echo "macos" ;;
              Linux) echo "linux" ;;
              MINGW*|MSYS*|CYGWIN*) echo "windows" ;;
              *) echo "unsupported" ;;
            esac
          }
          result=$(detect_os)
          echo "Detected OS: $result"
          [ "$result" = "linux" ] || exit 1

      - name: Test architecture detection function
        run: |
          # Define the function directly
          detect_arch() {
            case "$(uname -m)" in
              x86_64|amd64) echo "x86_64" ;;
              arm64|aarch64) echo "aarch64" ;;
              *) echo "unsupported" ;;
            esac
          }
          result=$(detect_arch)
          echo "Detected arch: $result"
          [ "$result" = "x86_64" ] || [ "$result" = "aarch64" ] || exit 1

      # Test install directory creation
      - name: Test install directory creation
        run: |
          mkdir -p "$HOME/.local/bin"
          [ -d "$HOME/.local/bin" ] || exit 1
          echo "Install directory created successfully"

      # Test model directory creation
      - name: Test model directory creation
        run: |
          mkdir -p "$HOME/.config/fix"
          [ -d "$HOME/.config/fix" ] || exit 1
          echo "Model directory created successfully"

      # Simulate binary installation (without actual download)
      - name: Simulate binary installation
        run: |
          # Create a mock binary
          echo '#!/bin/bash' > "$HOME/.local/bin/fix"
          echo 'echo "git status"' >> "$HOME/.local/bin/fix"
          chmod +x "$HOME/.local/bin/fix"

          # Verify binary works
          result=$("$HOME/.local/bin/fix" "gti status")
          echo "Mock binary output: $result"
          [ "$result" = "git status" ] || exit 1

  test-install-script-macos:
    name: Test install.sh (macOS)
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4

      - name: Check script syntax
        run: bash -n website/install.sh

      - name: Test OS detection function
        run: |
          # Define the function directly (macOS sed has different behavior)
          detect_os() {
            case "$(uname -s)" in
              Darwin) echo "macos" ;;
              Linux) echo "linux" ;;
              MINGW*|MSYS*|CYGWIN*) echo "windows" ;;
              *) echo "unsupported" ;;
            esac
          }
          result=$(detect_os)
          echo "Detected OS: $result"
          [ "$result" = "macos" ] || exit 1

      - name: Test architecture detection function
        run: |
          # Define the function directly
          detect_arch() {
            case "$(uname -m)" in
              x86_64|amd64) echo "x86_64" ;;
              arm64|aarch64) echo "aarch64" ;;
              *) echo "unsupported" ;;
            esac
          }
          result=$(detect_arch)
          echo "Detected arch: $result"
          [ "$result" = "aarch64" ] || exit 1

      - name: Test install directory creation
        run: |
          mkdir -p "$HOME/.local/bin"
          [ -d "$HOME/.local/bin" ] || exit 1

      # Test macOS model path (Library/Application Support)
      - name: Test macOS config directory
        run: |
          # The CLI uses dirs::config_dir() which on macOS is ~/Library/Application Support
          config_dir="$HOME/Library/Application Support/fix"
          mkdir -p "$config_dir"
          [ -d "$config_dir" ] || exit 1
          echo "macOS config directory created: $config_dir"

  test-install-ps1-windows:
    name: Test install.ps1 (Windows)
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      # Test PowerShell script syntax
      - name: Check script syntax
        shell: pwsh
        run: |
          $errors = $null
          $ast = [System.Management.Automation.Language.Parser]::ParseFile(
            "website/install.ps1",
            [ref]$null,
            [ref]$errors
          )
          if ($errors.Count -gt 0) {
            $errors | ForEach-Object { Write-Error $_.Message }
            exit 1
          }
          Write-Host "PowerShell script syntax is valid"

      # Test architecture detection
      - name: Test architecture detection
        shell: pwsh
        run: |
          $arch = if ([Environment]::Is64BitOperatingSystem) { "x86_64" } else { "i686" }
          Write-Host "Detected architecture: $arch"
          if ($arch -ne "x86_64") {
            Write-Error "Expected x86_64 on GitHub runner"
            exit 1
          }

      # Test install directory creation
      - name: Test install directory creation
        shell: pwsh
        run: |
          $installDir = "$env:LOCALAPPDATA\fix"
          New-Item -ItemType Directory -Path $installDir -Force | Out-Null
          if (-not (Test-Path $installDir)) {
            Write-Error "Failed to create install directory"
            exit 1
          }
          Write-Host "Install directory created: $installDir"

      # Test model directory creation (APPDATA)
      - name: Test model directory creation
        shell: pwsh
        run: |
          $modelDir = "$env:APPDATA\fix"
          New-Item -ItemType Directory -Path $modelDir -Force | Out-Null
          if (-not (Test-Path $modelDir)) {
            Write-Error "Failed to create model directory"
            exit 1
          }
          Write-Host "Model directory created: $modelDir"

      # Test PATH modification logic
      - name: Test PATH modification
        shell: pwsh
        run: |
          $installDir = "$env:LOCALAPPDATA\fix"
          $testPath = "C:\existing\path;C:\another\path"

          # Test that we can detect if path is not in PATH
          if ($testPath -notlike "*$installDir*") {
            Write-Host "Correctly detected install dir not in PATH"
          } else {
            Write-Error "PATH detection logic failed"
            exit 1
          }

          # Test that we can detect if path IS in PATH
          $testPath2 = "$testPath;$installDir"
          if ($testPath2 -like "*$installDir*") {
            Write-Host "Correctly detected install dir in PATH"
          } else {
            Write-Error "PATH detection logic failed"
            exit 1
          }

      # Test profile path detection
      - name: Test profile path detection
        shell: pwsh
        run: |
          $profilePath = $PROFILE.CurrentUserCurrentHost
          Write-Host "PowerShell profile path: $profilePath"
          if (-not $profilePath) {
            Write-Error "Could not determine profile path"
            exit 1
          }

      # Simulate binary installation
      - name: Simulate binary installation
        shell: pwsh
        run: |
          $installDir = "$env:LOCALAPPDATA\fix"
          $exePath = "$installDir\fix.exe"

          # Create a mock executable (batch file renamed to .exe won't work, so just test path)
          "mock" | Out-File -FilePath $exePath

          if (Test-Path $exePath) {
            Write-Host "Mock binary created at: $exePath"
          } else {
            Write-Error "Failed to create mock binary"
            exit 1
          }

  test-install-wsl:
    name: Test install.sh (WSL)
    runs-on: windows-latest
    steps:
      - name: Configure git for LF line endings
        run: |
          git config --global core.autocrlf false
          git config --global core.eol lf

      - uses: actions/checkout@v4

      - name: Setup WSL
        uses: Vampire/setup-wsl@v3
        with:
          distribution: Ubuntu-22.04

      # Test WSL detection in the script
      - name: Test WSL detection
        shell: wsl-bash {0}
        run: |
          # The is_wsl function from install.sh
          is_wsl() {
            grep -qiE "(microsoft|wsl)" /proc/version 2>/dev/null
          }

          if is_wsl; then
            echo "Correctly detected WSL environment"
          else
            echo "ERROR: Should have detected WSL"
            exit 1
          fi

      - name: Check script syntax in WSL
        shell: wsl-bash {0}
        run: bash -n website/install.sh

      - name: Test OS detection in WSL
        shell: wsl-bash {0}
        run: |
          # Source the detect_os function
          detect_os() {
            case "$(uname -s)" in
              Darwin) echo "macos" ;;
              Linux) echo "linux" ;;
              MINGW*|MSYS*|CYGWIN*) echo "windows" ;;
              *) echo "unsupported" ;;
            esac
          }

          result=$(detect_os)
          echo "Detected OS in WSL: $result"
          [ "$result" = "linux" ] || exit 1

      - name: Test install directories in WSL
        shell: wsl-bash {0}
        run: |
          mkdir -p "$HOME/.local/bin"
          mkdir -p "$HOME/.config/fix"

          [ -d "$HOME/.local/bin" ] || exit 1
          [ -d "$HOME/.config/fix" ] || exit 1

          echo "WSL install directories created successfully"
          echo "Binary would go to: $HOME/.local/bin/fix"
          echo "Model would go to: $HOME/.config/fix/"

  test-shell-integration:
    name: Test Shell Integration Functions
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Test bash function syntax
      - name: Test bash function
        run: |
          # Test a simple bash function to verify syntax
          bash -c '
          fix() {
              if [[ -n "$1" ]]; then
                  echo "direct: $@"
              else
                  echo "No args"
              fi
          }
          result=$(fix "test command")
          echo "Result: $result"
          [[ "$result" == "direct: test command" ]] || exit 1
          '
          echo "Bash function syntax is valid"

      # Test zsh function syntax
      - name: Test zsh function
        run: |
          # Install zsh if needed
          sudo apt-get update && sudo apt-get install -y zsh

          # Test zsh function
          zsh -c '
          fix() {
              if [[ -n "$1" ]]; then
                  echo "direct: $@"
              else
                  echo "No args"
              fi
          }
          result=$(fix "test command")
          [[ "$result" == "direct: test command" ]] || exit 1
          '
          echo "Zsh function syntax is valid"

      # Test fish function syntax
      - name: Test fish function
        run: |
          # Install fish
          sudo apt-get install -y fish

          # Test fish function
          fish -c '
          function fix --description "Fix the last command"
              if test (count $argv) -gt 0
                  echo "direct: $argv"
              else
                  echo "No correction needed"
              end
          end
          fix "test command"
          ' | grep -q "direct: test command"
          echo "Fish function syntax is valid"

      # Test tcsh alias syntax
      - name: Test tcsh alias
        run: |
          # Install tcsh
          sudo apt-get install -y tcsh

          # Test tcsh alias (simplified version)
          tcsh -c '
          alias fixtest "echo test"
          fixtest
          ' | grep -q "test"
          echo "Tcsh alias syntax is valid"

  # Test that profile files are actually modified correctly
  test-profile-modification:
    name: Test Profile Modification
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Bash profile test
      - name: Test bash profile modification
        run: |
          # Backup existing bashrc
          cp ~/.bashrc ~/.bashrc.backup 2>/dev/null || true

          # Create a clean bashrc
          echo "# Clean bashrc for testing" > ~/.bashrc

          # Extract and run the bash function addition from install.sh
          cat >> ~/.bashrc <<'BASH_FUNC'

# fix - AI-powered shell command corrector
fix() {
    if [[ -n "$1" ]]; then
        command fix "$@"
    else
        local cmd=$(fc -ln -1 | sed 's/^[[:space:]]*//')
        local corrected=$(command fix "$cmd" 2>/dev/null)
        if [[ -n "$corrected" && "$corrected" != "$cmd" ]]; then
            echo "Correcting: $cmd → $corrected"
            read -e -i "$corrected" -p "» " final_cmd
            [[ -n "$final_cmd" ]] && eval "$final_cmd"
        else
            echo "No correction needed"
        fi
    fi
}
BASH_FUNC

          # Verify the profile contains the fix function
          grep -q "fix - AI-powered shell command corrector" ~/.bashrc || (echo "FAIL: Comment not found" && exit 1)
          grep -q "command fix" ~/.bashrc || (echo "FAIL: command fix not found" && exit 1)
          grep -q "fc -ln -1" ~/.bashrc || (echo "FAIL: fc command not found" && exit 1)

          echo "PASS: Bash profile modification verified"

          # Restore
          mv ~/.bashrc.backup ~/.bashrc 2>/dev/null || true

      # Zsh profile test
      - name: Test zsh profile modification
        run: |
          sudo apt-get update && sudo apt-get install -y zsh

          # Create clean zshrc
          echo "# Clean zshrc for testing" > ~/.zshrc

          # Add zsh function
          cat >> ~/.zshrc <<'ZSH_FUNC'

# fix - AI-powered shell command corrector
fix() {
    if [[ -n "$1" ]]; then
        command fix "$@"
    else
        local cmd=$(fc -ln -1 | sed 's/^[[:space:]]*//')
        local corrected=$(command fix "$cmd" 2>/dev/null)
        if [[ -n "$corrected" && "$corrected" != "$cmd" ]]; then
            echo "Correcting: $cmd → $corrected"
            print -z "$corrected"
        else
            echo "No correction needed"
        fi
    fi
}
ZSH_FUNC

          # Verify
          grep -q "fix - AI-powered shell command corrector" ~/.zshrc || exit 1
          grep -q "print -z" ~/.zshrc || exit 1

          echo "PASS: Zsh profile modification verified"

      # Fish function file test
      - name: Test fish function file creation
        run: |
          sudo apt-get install -y fish

          # Create fish function file
          mkdir -p ~/.config/fish/functions
          cat > ~/.config/fish/functions/fix.fish <<'FISH_FUNC'
# fix - AI-powered shell command corrector
function fix --description 'Fix the last command'
    if test (count $argv) -gt 0
        command fix $argv
    else
        set -l cmd (string trim (history --max=1))
        set -l corrected (command fix "$cmd" 2>/dev/null)
        if test -n "$corrected" -a "$corrected" != "$cmd"
            echo "Correcting: $cmd → $corrected"
            commandline -r "$corrected"
            commandline -f repaint
        else
            echo "No correction needed"
        end
    end
end
FISH_FUNC

          # Verify file exists and has correct content
          [ -f ~/.config/fish/functions/fix.fish ] || exit 1
          grep -q "fix - AI-powered shell command corrector" ~/.config/fish/functions/fix.fish || exit 1
          grep -q "commandline -r" ~/.config/fish/functions/fix.fish || exit 1

          echo "PASS: Fish function file creation verified"

      # Tcsh profile test
      - name: Test tcsh profile modification
        run: |
          sudo apt-get install -y tcsh

          # Create clean tcshrc
          echo "# Clean tcshrc for testing" > ~/.tcshrc

          # Add tcsh alias
          cat >> ~/.tcshrc <<'TCSH_FUNC'

# fix - AI-powered shell command corrector
alias fixlast 'set _cmd = `history -h 1` && set _fix = `fix "$_cmd"` && echo "Correcting: $_cmd -> $_fix" && eval "$_fix"'
TCSH_FUNC

          # Verify
          grep -q "fix - AI-powered shell command corrector" ~/.tcshrc || exit 1
          grep -q "alias fixlast" ~/.tcshrc || exit 1

          echo "PASS: Tcsh profile modification verified"

      # Test idempotency - running configure twice shouldn't duplicate
      - name: Test idempotency (no duplicate entries)
        run: |
          # Create bashrc with function already present
          echo "# Clean bashrc" > ~/.bashrc
          echo "" >> ~/.bashrc
          echo "# fix - AI-powered shell command corrector" >> ~/.bashrc
          echo "fix() { echo test; }" >> ~/.bashrc

          # Count occurrences before
          count_before=$(grep -c "fix - AI-powered shell command corrector" ~/.bashrc)

          # Simulate what install.sh does - check if already configured
          if grep -q "fix - AI-powered shell command corrector" ~/.bashrc 2>/dev/null; then
            echo "Already configured - skipping"
          else
            echo "Would add function"
          fi

          # Count occurrences after
          count_after=$(grep -c "fix - AI-powered shell command corrector" ~/.bashrc)

          if [ "$count_before" = "$count_after" ]; then
            echo "PASS: Idempotency check - no duplicates added"
          else
            echo "FAIL: Duplicate entries were added"
            exit 1
          fi

  # Full end-to-end installation test with actual binaries
  test-full-install-linux:
    name: Full Install Test (Linux, ${{ matrix.shell }})
    runs-on: ubuntu-latest
    needs: build-binaries
    strategy:
      fail-fast: false
      matrix:
        shell: [bash, zsh, fish]
    steps:
      - uses: actions/checkout@v4

      - name: Download pre-built binary
        uses: actions/download-artifact@v4
        with:
          name: fix-binary-x86_64-unknown-linux-gnu
          path: binary

      - name: Install shell
        if: matrix.shell != 'bash'
        run: |
          sudo apt-get update
          sudo apt-get install -y ${{ matrix.shell }}

      - name: Install binary to ~/.local/bin
        run: |
          mkdir -p ~/.local/bin
          cp binary/fix-x86_64-unknown-linux-gnu ~/.local/bin/fix
          chmod +x ~/.local/bin/fix
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Verify binary works
        run: |
          ~/.local/bin/fix --help
          ~/.local/bin/fix --version

      - name: Setup shell profile
        run: |
          export SHELL=$(which ${{ matrix.shell }})
          echo "Setting up shell integration for $SHELL"

          case "${{ matrix.shell }}" in
            bash)
              cat >> ~/.bashrc <<'FUNC'

# fix - AI-powered shell command corrector
fix() {
    if [[ -n "$1" ]]; then
        command fix "$@"
    else
        echo "No command specified"
    fi
}
FUNC
              ;;
            zsh)
              cat >> ~/.zshrc <<'FUNC'

# fix - AI-powered shell command corrector
fix() {
    if [[ -n "$1" ]]; then
        command fix "$@"
    else
        echo "No command specified"
    fi
}
FUNC
              ;;
            fish)
              mkdir -p ~/.config/fish/functions
              cat > ~/.config/fish/functions/fix.fish <<'FUNC'
function fix --description 'Fix the last command'
    if test (count $argv) -gt 0
        command fix $argv
    else
        echo "No command specified"
    end
end
FUNC
              ;;
          esac

      - name: Test shell function invokes binary
        run: |
          # Test that the shell function can call the binary
          case "${{ matrix.shell }}" in
            bash)
              bash -c 'source ~/.bashrc && fix --help' | grep -q "AI-powered"
              ;;
            zsh)
              zsh -c 'source ~/.zshrc && fix --help' | grep -q "AI-powered"
              ;;
            fish)
              fish -c 'fix --help' | grep -q "AI-powered"
              ;;
          esac
          echo "PASS: Shell function correctly invokes binary"

  test-full-install-macos:
    name: Full Install Test (macOS)
    runs-on: macos-14
    needs: build-binaries
    steps:
      - uses: actions/checkout@v4

      - name: Download pre-built binary
        uses: actions/download-artifact@v4
        with:
          name: fix-binary-aarch64-apple-darwin
          path: binary

      - name: Install binary
        run: |
          mkdir -p ~/.local/bin
          cp binary/fix-aarch64-apple-darwin ~/.local/bin/fix
          chmod +x ~/.local/bin/fix
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Verify binary works
        run: |
          ~/.local/bin/fix --help
          ~/.local/bin/fix --version

      - name: Setup zsh profile (macOS default)
        run: |
          cat >> ~/.zshrc <<'FUNC'

# fix - AI-powered shell command corrector
fix() {
    if [[ -n "$1" ]]; then
        command fix "$@"
    else
        echo "No command specified"
    fi
}
FUNC

      - name: Test zsh function invokes binary
        run: |
          zsh -c 'source ~/.zshrc && fix --help' | grep -q "AI-powered"
          echo "PASS: Zsh function correctly invokes binary on macOS"

  test-full-install-windows:
    name: Full Install Test (Windows)
    runs-on: windows-latest
    needs: build-binaries
    steps:
      - uses: actions/checkout@v4

      - name: Download pre-built binary
        uses: actions/download-artifact@v4
        with:
          name: fix-binary-x86_64-pc-windows-msvc
          path: binary

      - name: Install binary
        shell: pwsh
        run: |
          $installDir = "$env:LOCALAPPDATA\fix"
          New-Item -ItemType Directory -Path $installDir -Force | Out-Null
          Copy-Item binary/fix-x86_64-pc-windows-msvc.exe "$installDir\fix.exe"
          echo "$installDir" >> $env:GITHUB_PATH

      - name: Verify binary works
        shell: pwsh
        run: |
          & "$env:LOCALAPPDATA\fix\fix.exe" --help
          & "$env:LOCALAPPDATA\fix\fix.exe" --version

      - name: Setup PowerShell profile
        shell: pwsh
        run: |
          $profileDir = Split-Path $PROFILE.CurrentUserCurrentHost -Parent
          New-Item -ItemType Directory -Path $profileDir -Force | Out-Null

          @'
# fix - AI-powered shell command corrector
function fix {
    param([Parameter(ValueFromRemainingArguments=$true)]$args)
    $fixPath = "$env:LOCALAPPDATA\fix\fix.exe"
    if ($args) {
        & $fixPath @args
    } else {
        Write-Host "No command specified"
    }
}
'@ | Out-File -Append -FilePath $PROFILE.CurrentUserCurrentHost

      - name: Test PowerShell function invokes binary
        shell: pwsh
        run: |
          . $PROFILE.CurrentUserCurrentHost
          $output = fix --help
          if ($output -match "AI-powered") {
            Write-Host "PASS: PowerShell function correctly invokes binary"
          } else {
            Write-Error "FAIL: Function output doesn't contain expected text"
            exit 1
          }
